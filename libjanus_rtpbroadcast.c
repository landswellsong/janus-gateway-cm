/*! \file   cm_rtpbcast.c
 * \author Lorenzo Miniero <lorenzo@meetecho.com>
 * \copyright GNU General Public License v3
 * \brief  Janus Streaming plugin
 * \details  This is a streaming plugin for Janus, allowing WebRTC peers
 * to watch/listen to pre-recorded files or media generated by another tool.
 * Specifically, the plugin currently supports three different type of streams:
 *
 * -# on-demand streaming of pre-recorded media files (different
 * streaming context for each peer);
 * -# live streaming of pre-recorded media files (shared streaming
 * context for all peers attached to the stream);
 * -# live streaming of media generated by another tool (shared
 * streaming context for all peers attached to the stream).
 *
 * For what concerns types 1. and 2., considering the proof of concept
 * nature of the implementation the only pre-recorded media files
 * that the plugins supports right now are raw mu-Law and a-Law files:
 * support is of course planned for other additional widespread formats
 * as well.
 *
 * For what concerns type 3., instead, the plugin is configured
 * to listen on a couple of ports for RTP: this means that the plugin
 * is implemented to receive RTP on those ports and relay them to all
 * peers attached to that stream. Any tool that can generate audio/video
 * RTP streams and specify a destination is good for the purpose: the
 * examples section contains samples that make use of GStreamer (http://gstreamer.freedesktop.org/)
 * but other tools like FFmpeg (http://www.ffmpeg.org/), LibAV (http://libav.org/)
 * or others are fine as well. This makes it really easy to capture and
 * encode whatever you want using your favourite tool, and then have it
 * transparently broadcasted via WebRTC using Janus.
 *
 * Streams to make available are listed in the plugin configuration file.
 * A pre-filled configuration file is provided in \c conf/janus.plugin.streaming.cfg
 * and includes a stream of every type.
 *
 * To add more streams or modify the existing ones, you can use the following
 * syntax:
 *
 * \verbatim
[stream-name]
type = rtp|live|ondemand|rtsp
       rtp = stream originated by an external tool (e.g., gstreamer or
             ffmpeg) and sent to the plugin via RTP
       live = local file streamed live to multiple listeners
              (multiple listeners = same streaming context)
       ondemand = local file streamed on-demand to a single listener
                  (multiple listeners = different streaming contexts)
       rtsp = stream originated by an external RTSP feed (only
              available if libcurl support was compiled)
id = <unique numeric ID>
description = This is my awesome stream
is_private = yes|no (private streams don't appear when you do a 'list' request)
filename = path to the local file to stream (only for live/ondemand)
secret = <optional password needed for manipulating (e.g., destroying
		or enabling/disabling) the stream>
pin = <optional password needed for watching the stream>
audio = yes|no (do/don't stream audio)
video = yes|no (do/don't stream video)
   The following options are only valid for the 'rtp' type:
audioport = local port for receiving audio frames
audiomcast = multicast group port for receiving audio frames, if any
audiopt = <audio RTP payload type> (e.g., 111)
audiortpmap = RTP map of the audio codec (e.g., opus/48000/2)
audiofmtp = Codec specific parameters, if any
videoport = local port for receiving video frames (only for rtp)
videomcast = multicast group port for receiving video frames, if any
videopt = <video RTP payload type> (e.g., 100)
videortpmap = RTP map of the video codec (e.g., VP8/90000)
videofmtp = Codec specific parameters, if any
   The following options are only valid for the 'rstp' type:
url = RTSP stream URL (only if type=rtsp)
\endverbatim
 *
 * \section streamapi Streaming API
 *
 * The Streaming API supports several requests, some of which are
 * synchronous and some asynchronous. There are some situations, though,
 * (invalid JSON, invalid request) which will always result in a
 * synchronous error response even for asynchronous requests.
 *
 * \c list , \c create , \c destroy , \c recording , \c enable and
 * \c disable are synchronous requests, which means you'll
 * get a response directly within the context of the transaction. \c list
 * lists all the available streams; \c create allows you to create a new
 * mountpoint dynamically, as an alternative to using the configuration
 * file; \c destroy removes a mountpoint and destroys it; \c recording
 * instructs the plugin on whether or not a live RTP stream should be
 * recorded while it's broadcasted; \c enable and \c disable respectively
 * enable and disable a mountpoint, that is decide whether or not a
 * mountpoint should be available to users without destroying it.
 *
 * The \c watch , \c start , \c pause , \c switch and \c stop requests
 * instead are all asynchronous, which means you'll get a notification
 * about their success or failure in an event. \c watch asks the plugin
 * to prepare the playout of one of the available streams; \c start
 * starts the actual playout; \c pause allows you to pause a playout
 * without tearing down the PeerConnection; \c switch allows you to
 * switch to a different mountpoint of the same kind (note: only live
 * RTP mountpoints supported as of now) without having to stop and watch
 * the new one; \c stop stops the playout and tears the PeerConnection
 * down.
 *
 * Actual API docs: TBD.
 *
 * \ingroup plugins
 * \ref plugins
 */

#include "plugins/plugin.h"

#include <jansson.h>
#include <errno.h>
/* TODO @landswellsong those are not really portable, are they? */
#include <sys/poll.h>
#include <sys/time.h>
#include <netdb.h>
#include <netinet/ip.h>
#include <netinet/udp.h>

#include "debug.h"
#include "apierror.h"
#include "config.h"
#include "mutex.h"
#include "rtp.h"
#include "rtcp.h"
#include "record.h"
#include "utils.h"


/* Plugin information */
#define CM_RTPBCAST_VERSION			5
#define CM_RTPBCAST_VERSION_STRING	"0.0.5"
#define CM_RTPBCAST_DESCRIPTION		"This is a streaming plugin for Janus, allowing WebRTC peers to watch/listen to pre-recorded files or media generated by gstreamer."
#define CM_RTPBCAST_NAME			"JANUS CM video plugin"
#define CM_RTPBCAST_AUTHOR			"Meetecho s.r.l."
#define CM_RTPBCAST_PACKAGE			"janus.plugin.cm.rtpbroadcast"

/* Plugin methods */
janus_plugin *create(void);
int cm_rtpbcast_init(janus_callbacks *callback, const char *config_path);
void cm_rtpbcast_destroy(void);
int cm_rtpbcast_get_api_compatibility(void);
int cm_rtpbcast_get_version(void);
const char *cm_rtpbcast_get_version_string(void);
const char *cm_rtpbcast_get_description(void);
const char *cm_rtpbcast_get_name(void);
const char *cm_rtpbcast_get_author(void);
const char *cm_rtpbcast_get_package(void);
void cm_rtpbcast_create_session(janus_plugin_session *handle, int *error);
struct janus_plugin_result *cm_rtpbcast_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp);
void cm_rtpbcast_setup_media(janus_plugin_session *handle);
void cm_rtpbcast_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len);
void cm_rtpbcast_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len);
void cm_rtpbcast_hangup_media(janus_plugin_session *handle);
void cm_rtpbcast_destroy_session(janus_plugin_session *handle, int *error);
char *cm_rtpbcast_query_session(janus_plugin_session *handle);

/* Plugin setup */
static janus_plugin cm_rtpbcast_plugin =
	JANUS_PLUGIN_INIT (
		.init = cm_rtpbcast_init,
		.destroy = cm_rtpbcast_destroy,

		.get_api_compatibility = cm_rtpbcast_get_api_compatibility,
		.get_version = cm_rtpbcast_get_version,
		.get_version_string = cm_rtpbcast_get_version_string,
		.get_description = cm_rtpbcast_get_description,
		.get_name = cm_rtpbcast_get_name,
		.get_author = cm_rtpbcast_get_author,
		.get_package = cm_rtpbcast_get_package,

		.create_session = cm_rtpbcast_create_session,
		.handle_message = cm_rtpbcast_handle_message,
		.setup_media = cm_rtpbcast_setup_media,
		.incoming_rtp = cm_rtpbcast_incoming_rtp,
		.incoming_rtcp = cm_rtpbcast_incoming_rtcp,
		.hangup_media = cm_rtpbcast_hangup_media,
		.destroy_session = cm_rtpbcast_destroy_session,
		.query_session = cm_rtpbcast_query_session,
	);

/* Plugin creator */
janus_plugin *create(void) {
	JANUS_LOG(LOG_VERB, "%s created!\n", CM_RTPBCAST_NAME);
	return &cm_rtpbcast_plugin;
}


/* Useful stuff */
static volatile gint initialized = 0, stopping = 0;
static janus_callbacks *gateway = NULL;
static GThread *handler_thread;
static GThread *watchdog;
static void *cm_rtpbcast_handler(void *data);
static void cm_rtpbcast_relay_rtp_packet(gpointer data, gpointer user_data);
static void *cm_rtpbcast_relay_thread(void *data);
static char *str_replace(char *instr, const char *needle, const char *replace);

/* Helper to remove insane code duplication everywhere
 	 Sample illustrating use:
			something things[] = { X, Y, Z };
			_foreach(i, things) {
				print(things[i]);
			}

			Note, iterator variable exported in the current scope;
			*/
#define _foreach(var, container) size_t var; for (var = 0; var < sizeof(container)/sizeof(container[0]); var++)

/* To remove unnecessary duplication all over, all things are arrays of 2 now
 	 i.e. instead of audio_port you have port[AUDIO]
	 As a bonus, av_names[AUDIO] is "audio" string and so on
*/
#define AUDIO 0
#define VIDEO 1
#define AV		2
const char *av_names[] = { "audio", "video" };

static struct {
	guint minport, maxport;
	const char *job_path;
	const char *job_pattern;
	const char *archive_path;
	const char *recording_pattern;
	const char *thumbnailing_pattern;
	guint thumbnailing_interval;
	guint thumbnailing_duration;
	guint downgrade_avg_time;
	guint upgrade_avg_time;
} cm_rtpbcast_settings;

typedef struct cm_rtpbcast_codecs {
	gint pt[AV];
	char *rtpmap[AV];
	char *fmtp[AV];
} cm_rtpbcast_codecs;

#define STAT_UPDATE_DELAY 1000000
typedef struct cm_rtpbcast_stats {
	gdouble min;
	gdouble max;
	gdouble cur;
	gdouble avg;
	gdouble cur_up;
	gdouble cur_down;

	guint64 start_usec;
	guint64 last_avg_usec;
	guint64 last_avg_up_usec;
	guint64 last_avg_down_usec;
	guint64 bytes_since_start;
	guint64 bytes_since_last_avg;
	guint64 bytes_since_last_avg_up;
	guint64 bytes_since_last_avg_down;

	janus_mutex stat_mutex;
} cm_rtpbcast_stats;
static void cm_rtpbcast_stats_restart(cm_rtpbcast_stats *);
static void cm_rtpbcast_stats_update(cm_rtpbcast_stats *, int);

/* Forward declaration for pointer */
typedef struct cm_rtpbcast_session cm_rtpbcast_session;
typedef struct cm_rtpbcast_mountpoint {
	char *id;
	char *name;
	char *description;

	gboolean enabled;

	gboolean recorded; 		  /* Only sources[0] is recorded by default */
	janus_recorder *rc[AV];	/* The Janus recorder instance for this mountpoint's audio/video, if enabled */
	janus_recorder *trc[1];	/* Thumbnailing recorder, array for generic code sake */
	guint64 last_thumbnail; /* Positon (frames/time) of last thumbnail taken */
	gboolean whitelisted;
	struct in_addr allowed_ip;

	GArray *sources; // of type cm_rtpbcast_rtp_source*
	gint64 destroyed;

	cm_rtpbcast_session *session;
} cm_rtpbcast_mountpoint;
GHashTable *mountpoints;
static GList *old_mountpoints;
janus_mutex mountpoints_mutex;
/* TODO @landswellsong per-source recording */
static void cm_rtpbcast_start_recording(cm_rtpbcast_mountpoint *);
static void cm_rtpbcast_stop_recording(cm_rtpbcast_mountpoint *);
static void cm_rtpbcast_start_thumbnailing(cm_rtpbcast_mountpoint *);
static void cm_rtpbcast_stop_thumbnailing(cm_rtpbcast_mountpoint *);

typedef struct cm_rtpbcast_rtp_source {
	gboolean active;
	guint port[AV];
	in_addr_t mcast[AV];
	int fd[AV];
	cm_rtpbcast_codecs codecs;
	cm_rtpbcast_stats stats;
	cm_rtpbcast_mountpoint *mp;

	GList/*<unowned cm_rtpbcast_session>*/ *listeners;
	janus_mutex mutex;
} cm_rtpbcast_rtp_source;
static cm_rtpbcast_rtp_source* cm_rtpbcast_pick_source(GArray/* cm_rtpbcast_rtp_source* */ *, guint64);

/* The idea is, keep pointers to sources in hash table and keep track of
	 available ports in the shuffled list. When a port is fred, it is inserted
	 at a random poisition back in the list, thus the computatonally intensive
	 operations are carried at startup and at source destruction only
	 */
static struct {
	GHashTable *used_ports;
	GList *free_ports;
	janus_mutex used_ports_mutex;
	guint ports_available;					/* GList doesn't keep track of size */
} port_manager;
static void cm_rtpbcast_port_manager_init();
static guint cm_rtpbcast_port_manager_assign(gpointer);
static void cm_rtpbcast_port_manager_free(guint);
static void cm_rtpbcast_port_manager_destroy();

static void cm_rtpbcast_mountpoint_free(cm_rtpbcast_mountpoint *mp);
static void cm_rtpbcast_mountpoint_destroy(gpointer data, gpointer user_data);

/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
typedef struct cm_rtpbcast_rtp_source_request {
	char *mcast[AV];
	uint8_t codec[AV];
	char *rtpmap[AV];
	char *fmtp[AV];
} cm_rtpbcast_rtp_source_request;

typedef struct cm_rtpbcast_rtp_relay_thread_data {
	cm_rtpbcast_mountpoint *mp;
	guint i;
} cm_rtpbcast_rtp_relay_thread_data;

cm_rtpbcast_mountpoint *cm_rtpbcast_create_rtp_source(
		char* id, char *name, char *desc, gboolean recorded,
		const char *allowed_ip, GArray *requests);

typedef struct cm_rtpbcast_message {
	janus_plugin_session *handle;
	char *transaction;
	json_t *message;
	char *sdp_type;
	char *sdp;
} cm_rtpbcast_message;
static GAsyncQueue *messages = NULL;

void cm_rtpbcast_message_free(cm_rtpbcast_message *msg);
void cm_rtpbcast_message_free(cm_rtpbcast_message *msg) {
	if(!msg)
		return;

	msg->handle = NULL;

	g_free(msg->transaction);
	msg->transaction = NULL;
	if(msg->message)
		json_decref(msg->message);
	msg->message = NULL;
	g_free(msg->sdp_type);
	msg->sdp_type = NULL;
	g_free(msg->sdp);
	msg->sdp = NULL;

	g_free(msg);
}


typedef struct cm_rtpbcast_context {
	/* Needed to fix seq and ts in case of stream switching */
	uint32_t last_ssrc[AV], last_ts[AV], base_ts[AV], base_ts_prev[AV];
	uint16_t last_seq[AV], base_seq[AV], base_seq_prev[AV];
} cm_rtpbcast_context;

typedef struct cm_rtpbcast_session {
	janus_plugin_session *handle;
	cm_rtpbcast_rtp_source *source;
	guint64 remb;
	gboolean started;
	gboolean paused;
	cm_rtpbcast_context context;
	GList/*cm_rtpbcast_mountpoint*/ *mps;
	gboolean stopping;
	volatile gint hangingup;
	gint64 destroyed;	/* Time at which this session was marked as destroyed */
} cm_rtpbcast_session;
static GHashTable *sessions;
static GList *old_sessions;
static janus_mutex sessions_mutex;
static void cm_rtpbcast_store_event(json_t* , const char *);

/* Packets we get from gstreamer and relay */
typedef struct cm_rtpbcast_rtp_relay_packet {
	rtp_header *data;
	gint length;
	gint is_video;
	uint32_t timestamp;
	uint16_t seq_number;
} cm_rtpbcast_rtp_relay_packet;


/* Error codes */
#define CM_RTPBCAST_ERROR_NO_MESSAGE			450
#define CM_RTPBCAST_ERROR_INVALID_JSON			451
#define CM_RTPBCAST_ERROR_INVALID_REQUEST		452
#define CM_RTPBCAST_ERROR_MISSING_ELEMENT		453
#define CM_RTPBCAST_ERROR_INVALID_ELEMENT		454
#define CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT	455
#define CM_RTPBCAST_ERROR_CANT_CREATE			456
#define CM_RTPBCAST_ERROR_UNAUTHORIZED			457
#define CM_RTPBCAST_ERROR_CANT_SWITCH			458
#define CM_RTPBCAST_ERROR_UNKNOWN_ERROR			470


/* Streaming watchdog/garbage collector (sort of) */
void *cm_rtpbcast_watchdog(void *data);
void *cm_rtpbcast_watchdog(void *data) {
	JANUS_LOG(LOG_INFO, "CM RTP Broadcast watchdog started\n");
	gint64 now = 0;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		janus_mutex_lock(&sessions_mutex);
		/* Iterate on all the sessions */
		now = janus_get_monotonic_time();
		if(old_sessions != NULL) {
			GList *sl = old_sessions;
			JANUS_LOG(LOG_HUGE, "Checking %d old CM RTP Broadcast sessions...\n", g_list_length(old_sessions));
			while(sl) {
				cm_rtpbcast_session *session = (cm_rtpbcast_session *)sl->data;
				if(!session) {
					sl = sl->next;
					continue;
				}
				if(now-session->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old CM RTP Broadcast session\n");
					GList *rm = sl->next;
					old_sessions = g_list_delete_link(old_sessions, sl);
					sl = rm;
					session->handle = NULL;
					g_free(session);
					session = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&sessions_mutex);
		janus_mutex_lock(&mountpoints_mutex);
		/* Iterate on all the mountpoints */
		if(old_mountpoints != NULL) {
			GList *sl = old_mountpoints;
			JANUS_LOG(LOG_HUGE, "Checking %d old CM RTP Broadcast mountpoints...\n", g_list_length(old_mountpoints));
			while(sl) {
				cm_rtpbcast_mountpoint *mountpoint = (cm_rtpbcast_mountpoint *)sl->data;
				if(!mountpoint) {
					sl = sl->next;
					continue;
				}
				if(now-mountpoint->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old CM RTP Broadcast mountpoint\n");
					GList *rm = sl->next;
					old_mountpoints = g_list_delete_link(old_mountpoints, sl);
					sl = rm;
					cm_rtpbcast_mountpoint_free(mountpoint);
					mountpoint = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&mountpoints_mutex);
		g_usleep(500000);
	}
	JANUS_LOG(LOG_INFO, "CM RTP Broadcast watchdog stopped\n");
	return NULL;
}


/* Plugin implementation */
int cm_rtpbcast_init(janus_callbacks *callback, const char *config_path) {
	if(g_atomic_int_get(&stopping)) {
		/* Still stopping from before */
		return -1;
	}
	if(callback == NULL || config_path == NULL) {
		/* Invalid arguments */
		return -1;
	}

	/* Read configuration */
	char filename[255];
	g_snprintf(filename, 255, "%s/%s.cfg", config_path, CM_RTPBCAST_PACKAGE);
	JANUS_LOG(LOG_VERB, "Configuration file: %s\n", filename);
	janus_config *config = janus_config_parse(filename);
	if(config != NULL)
		janus_config_print(config);

	/* Defauts */
	cm_rtpbcast_settings.minport = 8000;
	cm_rtpbcast_settings.maxport = 9000;
	cm_rtpbcast_settings.upgrade_avg_time = 10;
	cm_rtpbcast_settings.downgrade_avg_time = 2;
	cm_rtpbcast_settings.job_path =  g_strdup("/tmp/jobs");
	cm_rtpbcast_settings.job_pattern = g_strdup("job-#{md5}");
	cm_rtpbcast_settings.archive_path =  g_strdup("/tmp/recordings");
	cm_rtpbcast_settings.recording_pattern = g_strdup("rec-#{id}-#{time}-#{type}");
	cm_rtpbcast_settings.thumbnailing_pattern = g_strdup("thum-#{id}-#{time}-#{type}");
	cm_rtpbcast_settings.thumbnailing_interval = 60;
	cm_rtpbcast_settings.thumbnailing_duration = 10;

	mountpoints = g_hash_table_new_full(
		g_str_hash,	 /* Hashing func */
		g_str_equal, /* Key comparator */
		g_free,			 /* Key destructor */
		NULL);			 /* Value destructor, we don't want this done automatically */
	janus_mutex_init(&mountpoints_mutex);
	/* Parse configuration to populate the mountpoints */
	if(config != NULL) {
		/* Integers */
		{
			const char *inames [] = {
				"minport",
				"maxport",
				"thumbnailing_interval",
				"thumbnailing_duration",
				"upgrade_avg_time",
				"downgrade_avg_time"
			};
			guint *ivars [] = {
				&cm_rtpbcast_settings.minport,
				&cm_rtpbcast_settings.maxport,
				&cm_rtpbcast_settings.thumbnailing_interval,
				&cm_rtpbcast_settings.thumbnailing_duration,
				&cm_rtpbcast_settings.upgrade_avg_time,
				&cm_rtpbcast_settings.downgrade_avg_time
			};

			_foreach(i, ivars) {
				janus_config_item *itm = janus_config_get_item_drilldown(config, "general", inames[i]);
				if (itm && itm->value) {
					guint res = g_ascii_strtoull(itm->value, NULL, 10);
					if (res != 0)
						*ivars[i] = res;
				}
			}
		}
		/* Strings */
		{
			const char *inames [] = {
			 "job_path",
			 "job_pattern",
			 "archive_path",
			 "recording_pattern",
			 "thumbnailing_pattern"
		  };
			const char **ivars [] = {
				&cm_rtpbcast_settings.job_path,
				&cm_rtpbcast_settings.job_pattern,
				&cm_rtpbcast_settings.archive_path,
				&cm_rtpbcast_settings.recording_pattern,
				&cm_rtpbcast_settings.thumbnailing_pattern
			};

			_foreach(i, ivars) {
				janus_config_item *itm = janus_config_get_item_drilldown(config, "general", inames[i]);
				if (itm && itm->value) {
					g_free((gpointer)*ivars[i]);
					*ivars[i] = g_strdup(itm->value);
				}
			}
		}

		if(cm_rtpbcast_settings.minport > cm_rtpbcast_settings.maxport) {
			g_atomic_int_set(&initialized, 0);
			JANUS_LOG(LOG_ERR, "Configuration error: minport %d is bigger than maxport %d\n",
				cm_rtpbcast_settings.minport, cm_rtpbcast_settings.maxport);
			return -1;
		}

		/* Done */
		janus_config_destroy(config);
		config = NULL;
	}
	cm_rtpbcast_port_manager_init(cm_rtpbcast_settings.minport, cm_rtpbcast_settings.maxport);

	/* Not showing anything, no mountpoint configured at startup */
	sessions = g_hash_table_new(NULL, NULL);
	janus_mutex_init(&sessions_mutex);
	messages = g_async_queue_new_full((GDestroyNotify) cm_rtpbcast_message_free);
	/* This is the callback we'll need to invoke to contact the gateway */
	gateway = callback;
	g_atomic_int_set(&initialized, 1);

	GError *error = NULL;
	/* Start the sessions watchdog */
	watchdog = g_thread_try_new("rtpbroadcast watchdog", &cm_rtpbcast_watchdog, NULL, &error);
	if(!watchdog) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP broadcast watchdog thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	/* Launch the thread that will handle incoming messages */
	handler_thread = g_thread_try_new("janus rtpbroadcast handler", cm_rtpbcast_handler, NULL, &error);
	if(error != NULL) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP broadcast handler thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	JANUS_LOG(LOG_INFO, "%s initialized!\n", CM_RTPBCAST_NAME);
	return 0;
}

void cm_rtpbcast_destroy(void) {
	if(!g_atomic_int_get(&initialized))
		return;
	g_atomic_int_set(&stopping, 1);

	if(handler_thread != NULL) {
		g_thread_join(handler_thread);
		handler_thread = NULL;
	}

	/* Remove all mountpoints */
	janus_mutex_unlock(&mountpoints_mutex);
	GHashTableIter iter;
	gpointer value;
	g_hash_table_iter_init(&iter, mountpoints);
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		cm_rtpbcast_mountpoint *mp = value;
		if(!mp->destroyed) {
			mp->destroyed = janus_get_monotonic_time();
			old_mountpoints = g_list_append(old_mountpoints, mp);
		}
	}
	janus_mutex_unlock(&mountpoints_mutex);
	if(watchdog != NULL) {
		g_thread_join(watchdog);
		watchdog = NULL;
	}

	/* FIXME We should destroy the sessions cleanly */
	usleep(500000);
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_destroy(mountpoints); /* TODO: @landswellsong do we need to free them? */
	janus_mutex_unlock(&mountpoints_mutex);
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_destroy(sessions);
	janus_mutex_unlock(&sessions_mutex);
	cm_rtpbcast_port_manager_destroy();
	g_async_queue_unref(messages);
	messages = NULL;
	sessions = NULL;

	/* Freeing configuration strings */
	g_free((gpointer)cm_rtpbcast_settings.job_path);
	g_free((gpointer)cm_rtpbcast_settings.job_pattern);
	g_free((gpointer)cm_rtpbcast_settings.archive_path);
	g_free((gpointer)cm_rtpbcast_settings.recording_pattern);
	g_free((gpointer)cm_rtpbcast_settings.thumbnailing_pattern);

	g_atomic_int_set(&initialized, 0);
	g_atomic_int_set(&stopping, 0);
	JANUS_LOG(LOG_INFO, "%s destroyed!\n", CM_RTPBCAST_NAME);
}

int cm_rtpbcast_get_api_compatibility(void) {
	/* Important! This is what your plugin MUST always return: don't lie here or bad things will happen */
	return JANUS_PLUGIN_API_VERSION;
}

int cm_rtpbcast_get_version(void) {
	return CM_RTPBCAST_VERSION;
}

const char *cm_rtpbcast_get_version_string(void) {
	return CM_RTPBCAST_VERSION_STRING;
}

const char *cm_rtpbcast_get_description(void) {
	return CM_RTPBCAST_DESCRIPTION;
}

const char *cm_rtpbcast_get_name(void) {
	return CM_RTPBCAST_NAME;
}

const char *cm_rtpbcast_get_author(void) {
	return CM_RTPBCAST_AUTHOR;
}

const char *cm_rtpbcast_get_package(void) {
	return CM_RTPBCAST_PACKAGE;
}

void cm_rtpbcast_create_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)g_malloc0(sizeof(cm_rtpbcast_session));
	if(session == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		*error = -2;
		return;
	}
	session->handle = handle;
	session->source = NULL;	/* This will happen later */
	session->started = FALSE;	/* This will happen later */
	session->paused = FALSE;
	session->destroyed = 0;
	session->remb = 0;
	session->mps = NULL;

	g_atomic_int_set(&session->hangingup, 0);
	handle->plugin_handle = session;
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_insert(sessions, handle, session);
	janus_mutex_unlock(&sessions_mutex);

	return;
}

void cm_rtpbcast_destroy_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		*error = -2;
		return;
	}
	JANUS_LOG(LOG_VERB, "Removing CM RTP Broadcast session...\n");
	if(session->source) {
		janus_mutex_lock(&session->source->mutex);
		session->source->listeners = g_list_remove_all(session->source->listeners, session);
		janus_mutex_unlock(&session->source->mutex);
	}

	/* If this is a streamer session, kill the stream */
	if(session->mps)
		g_list_foreach(session->mps, cm_rtpbcast_mountpoint_destroy, NULL);
	session->mps = NULL;

	janus_mutex_lock(&sessions_mutex);
	if(!session->destroyed) {
		session->destroyed = janus_get_monotonic_time();
		g_hash_table_remove(sessions, handle);
		/* Cleaning up and removing the session is done in a lazy way */
		old_sessions = g_list_append(old_sessions, session);
	}
	janus_mutex_unlock(&sessions_mutex);
	return;
}

char *cm_rtpbcast_query_session(janus_plugin_session *handle) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		return NULL;
	}
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return NULL;
	}
	/* What is this user watching, if anything? */
	json_t *info = json_object();
	json_object_set_new(info, "state", json_string(session->source ? "watching" : "idle"));
	if(session->source) {
		/* TODO @landswellsong maybe also dump the # of the stream itself? */
		json_object_set_new(info, "mountpoint_id", json_string(session->source->mp->id));
		json_object_set_new(info, "mountpoint_name", session->source->mp->name ? json_string(session->source->mp->name) : NULL);
	}
	json_object_set_new(info, "destroyed", json_integer(session->destroyed));
	char *info_text = json_dumps(info, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(info);
	return info_text;
}

struct janus_plugin_result *cm_rtpbcast_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return janus_plugin_result_new(JANUS_PLUGIN_ERROR, g_atomic_int_get(&stopping) ? "Shutting down" : "Plugin not initialized");

	/* Pre-parse the message */
	int error_code = 0;
	char error_cause[512];
	json_t *root = NULL;
	json_t *response = NULL;

	/* This might need to be freed at error: label */
	GArray *sources = NULL;

	if(message == NULL) {
		JANUS_LOG(LOG_ERR, "No message??\n");
		error_code = CM_RTPBCAST_ERROR_NO_MESSAGE;
		g_snprintf(error_cause, 512, "%s", "No message??");
		goto error;
	}
	JANUS_LOG(LOG_VERB, "Handling message: %s\n", message);

	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		error_code = CM_RTPBCAST_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "session associated with this handle...");
		goto error;
	}
	if(session->destroyed) {
		JANUS_LOG(LOG_ERR, "Session has already been destroyed...\n");
		error_code = CM_RTPBCAST_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "Session has already been destroyed...");
		goto error;
	}
	json_error_t error;
	root = json_loads(message, 0, &error);
	if(!root) {
		JANUS_LOG(LOG_ERR, "JSON error: on line %d: %s\n", error.line, error.text);
		error_code = CM_RTPBCAST_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: on line %d: %s", error.line, error.text);
		goto error;
	}
	if(!json_is_object(root)) {
		JANUS_LOG(LOG_ERR, "JSON error: not an object\n");
		error_code = CM_RTPBCAST_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: not an object");
		goto error;
	}
	/* Get the request first */
	json_t *request = json_object_get(root, "request");
	if(!request) {
		JANUS_LOG(LOG_ERR, "Missing element (request)\n");
		error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
		g_snprintf(error_cause, 512, "Missing element (request)");
		goto error;
	}
	if(!json_is_string(request)) {
		JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
		error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
		g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
		goto error;
	}
	/* Some requests ('create' and 'destroy') can be handled synchronously */
	const char *request_text = json_string_value(request);
	if(!strcasecmp(request_text, "list")) {
		json_t *id = json_object_get(root, "id");
		if(id && !json_is_string(id) < 0) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}

		json_t *list = json_array();
		JANUS_LOG(LOG_VERB, "Request for the list of mountpoints\n");
		/* Return a list of all available mountpoints */
		janus_mutex_lock(&mountpoints_mutex);
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, mountpoints);
		while (g_hash_table_iter_next(&iter, NULL, &value)) {
			cm_rtpbcast_mountpoint *mp = value;

			/* If id is given, skip others */
			/* TODO: @landswellsong refactor this without a loop */
			if (id && strcmp(json_string_value(id), mp->id) != 0)
				continue;

			json_t *ml = json_object();
			json_object_set_new(ml, "id", json_string(mp->id));
			json_object_set_new(ml, "name", json_string(mp->name));
			json_object_set_new(ml, "description", json_string(mp->description));
			/* json_object_set_new(ml, "streamcount", json_integer(mp->sources->len)); */
			json_t *st = json_array();
			guint i;
			for (i = 0; i < mp->sources->len; i++) {
				cm_rtpbcast_rtp_source *src = g_array_index(mp->sources, cm_rtpbcast_rtp_source*, i);
				json_t *v = json_object();
				json_object_set_new(v, "audioport", json_integer(src->port[AUDIO]));
				json_object_set_new(v, "videoport", json_integer(src->port[VIDEO]));

				json_t *s = json_object();
				janus_mutex_lock(&src->stats.stat_mutex);
				json_object_set_new(s, "min", json_real(src->stats.min));
				json_object_set_new(s, "max", json_real(src->stats.max));
				json_object_set_new(s, "cur", json_real(src->stats.cur));
				json_object_set_new(s, "avg", json_real(src->stats.avg));
				json_object_set_new(s, "cur_up", json_real(src->stats.cur_up));
				json_object_set_new(s, "cur_down", json_real(src->stats.cur_down));
				janus_mutex_unlock(&src->stats.stat_mutex);

				json_object_set_new(v, "stats", s);

				json_array_append_new(st, v);
			}
			json_object_set_new(ml, "streams", st);
			/* TODO: @landswellsong do we need to list anything else here? */
			json_array_append_new(list, ml);
		}
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("list"));
		json_object_set_new(response, "list", list);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "create")) {
		/* Create a new stream */
		cm_rtpbcast_mountpoint *mp = NULL;

	  /* RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		json_t *name = json_object_get(root, "name");
		if(name && !json_is_string(name)) {
			JANUS_LOG(LOG_ERR, "Invalid element (name should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (name should be a string)");
			goto error;
		}
		json_t *desc = json_object_get(root, "description");
		if(desc && !json_is_string(desc)) {
			JANUS_LOG(LOG_ERR, "Invalid element (desc should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (desc should be a string)");
			goto error;
		}
		json_t *recorded = json_object_get(root, "recorded");
		if(recorded && !json_is_boolean(recorded)) {
			JANUS_LOG(LOG_ERR, "Invalid element (recorded should be a boolean)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (recorded should be a boolean)");
			goto error;
		}
		json_t *whitelist = json_object_get(root, "whitelist");
		if(whitelist && !json_is_string(whitelist)) {
			JANUS_LOG(LOG_ERR, "Invalid element (whitelist should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (whitelist should be a string)");
			goto error;
		}

		/* Streams is an array now, containing pairs of audio+video streams */
		json_t *streams = json_object_get(root, "streams");
		size_t nstreams = json_array_size(streams);
		if (nstreams==0 || !json_is_array(streams)) {
			JANUS_LOG(LOG_ERR, "Invalid element (streams should be a non-empty array)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (streams should be a non-empty array)");
			goto error;
		}

		sources = g_array_sized_new(FALSE, FALSE,
			sizeof(cm_rtpbcast_rtp_source_request), nstreams);
		size_t i;
		json_t *v;

		/* Jansson's nomenclature changed a bit between versions */
#ifdef json_array_foreach
		json_array_foreach(streams, i, v) {
#else
		for (i = 0; i < json_array_size(streams); i++) {
			v = json_array_get(streams, i);
#endif
			if (v && !json_is_object(v)) {
				JANUS_LOG(LOG_ERR, "Invalid element (streams elements should be objects)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (streams elements should be objects)");
				goto error;
			}

			cm_rtpbcast_rtp_source_request req = {
				NULL, NULL,
				0, 0,
				NULL, NULL,
				NULL, NULL,
			}; /* FIXME @landswellsong check if it's correct initialization */

			/* Audio/Video stream params */
			size_t j;
			for (j = AUDIO; j <= VIDEO; j++) {
				char tmpnm[512];

				g_snprintf(tmpnm, 512, "%smcast", av_names[j]);
				json_t *mcast = json_object_get(v, tmpnm);
				if(mcast && !json_is_string(mcast)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				} else {
					req.mcast[j] = (char *)json_string_value(mcast);
				}

				g_snprintf(tmpnm, 512, "%spt", av_names[j]);
				json_t *pt = json_object_get(v, tmpnm);
				if(!pt) {
					JANUS_LOG(LOG_ERR, "Missing element (%s)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (%s)", tmpnm);
					goto error;
				}
				if(!json_is_integer(pt) || json_integer_value(pt) < 0) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a positive integer)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a positive integer)", tmpnm);
					goto error;
				}
				req.codec[j] = json_integer_value(pt);

				g_snprintf(tmpnm, 512, "%srtpmap", av_names[j]);
				json_t *rtpmap = json_object_get(v, tmpnm);
				if(!rtpmap) {
					JANUS_LOG(LOG_ERR, "Missing element (%s)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (%s)", tmpnm);
					goto error;
				}
				if(!json_is_string(rtpmap)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				}
				req.rtpmap[j] = (char *)json_string_value(rtpmap);

				g_snprintf(tmpnm, 512, "%sfmtp", av_names[j]);
				json_t *fmtp = json_object_get(v, tmpnm);
				if(fmtp && !json_is_string(fmtp)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				}
				req.fmtp[j] = (char *)json_string_value(fmtp);
			}
			/* All done, append to array */
			g_array_append_val(sources, req);
		}
		if(id == NULL) {
			JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
		} else {
			janus_mutex_lock(&mountpoints_mutex);
			mp = g_hash_table_lookup(mountpoints, json_string_value(id));
			janus_mutex_unlock(&mountpoints_mutex);
			if(mp != NULL) {
				JANUS_LOG(LOG_ERR, "A stream with the provided ID already exists\n");
				error_code = CM_RTPBCAST_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "A stream with the provided ID already exists");
				goto error;
			}
		}
		mp = cm_rtpbcast_create_rtp_source(
				id ? (char *)json_string_value(id) : NULL,
				name ? (char *)json_string_value(name) : NULL,
				desc ? (char *)json_string_value(desc) : NULL,
				(!recorded) || json_is_true(recorded), 	/* Recorded by default */
				whitelist ? json_string_value(whitelist) : NULL,
				sources);
		if(mp == NULL) {
			JANUS_LOG(LOG_ERR, "Error creating 'rtp' stream...\n");
			error_code = CM_RTPBCAST_ERROR_CANT_CREATE;
			g_snprintf(error_cause, 512, "Error creating 'rtp' stream");
			goto error;
		}

		/* Associate mp with session */
		session->mps = g_list_prepend(session->mps, mp);
		mp->session = session;

		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("created"));
		json_object_set_new(response, "created", json_string(mp->name));
		json_t *ml = json_object();
		json_object_set_new(ml, "id", json_string(mp->id));
		json_object_set_new(ml, "description", json_string(mp->description));
/*		json_object_set_new(ml, "streamcount", json_integer(nstreams)); */
		json_t *st = json_array();
		for (i = 0; i < mp->sources->len; i++) {
			json_t *v = json_object();
			json_object_set_new(v, "audioport", json_integer(g_array_index(mp->sources, cm_rtpbcast_rtp_source*, i)->port[AUDIO]));
			json_object_set_new(v, "videoport", json_integer(g_array_index(mp->sources, cm_rtpbcast_rtp_source*, i)->port[VIDEO]));
			json_array_append_new(st, v);
		}
		json_object_set_new(ml, "streams", st);
		json_object_set_new(response, "stream", ml);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "destroy")) {
		/* Get rid of an existing stream (notice this doesn't remove it from the config file, though) */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id) < 0) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		const char *id_value = json_string_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		cm_rtpbcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
			error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
			goto error;
		}
		JANUS_LOG(LOG_VERB, "Request to unmount mountpoint/stream %s\n", id_value);
		cm_rtpbcast_mountpoint_destroy(mp, NULL);
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("destroyed"));
		json_object_set_new(response, "destroyed", json_string(id_value));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "recording")) {
		#if 0
		/* We can start/stop recording a live, RTP-based stream */
		json_t *action = json_object_get(root, "action");
		if(!action) {
			JANUS_LOG(LOG_ERR, "Missing element (action)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (action)");
			goto error;
		}
		if(!json_is_string(action)) {
			JANUS_LOG(LOG_ERR, "Invalid element (action should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (action should be a string)");
			goto error;
		}
		const char *action_text = json_string_value(action);
		if(strcasecmp(action_text, "start") && strcasecmp(action_text, "stop")) {
			JANUS_LOG(LOG_ERR, "Invalid action (should be start|stop)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid action (should be start|stop)");
			goto error;
		}
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		char *id_value = json_string_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		cm_rtpbcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
			error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
			goto error;
		}
		if(!strcasecmp(action_text, "start")) {
			/* Start a recording for audio and/or video */
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_string(audio)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a string)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a string)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_string(video)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a string)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a string)");
				goto error;
			}
			if((audio && mp->source->arc) || (video && mp->source->vrc)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Recording for audio and/or video already started for this stream\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Recording for audio and/or video already started for this stream");
				goto error;
			}
			if(!audio && !video) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Missing audio and/or video\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Missing audio and/or video");
				goto error;
			}
			if(audio) {
				const char *audiofile = json_string_value(audio);
				mp->source->arc = janus_recorder_create(NULL, 0, (char *)audiofile);
				if(mp->source->arc == NULL) {
					JANUS_LOG(LOG_ERR, "Error starting recorder for audio\n");
				} else {
					JANUS_LOG(LOG_INFO, "[%s] Audio recording started\n", mp->name);
				}
			}
			if(video) {
				const char *videofile = json_string_value(video);
				mp->source->vrc = janus_recorder_create(NULL, 1, (char *)videofile);
				if(mp->source->vrc == NULL) {
					JANUS_LOG(LOG_ERR, "Error starting recorder for video\n");
				} else {
					JANUS_LOG(LOG_INFO, "[%s] Video recording started\n", mp->name);
				}
			}
			janus_mutex_unlock(&mountpoints_mutex);
			/* Send a success response back */
			response = json_object();
			json_object_set_new(response, "streaming", json_string("ok"));
			goto plugin_response;
		} else if(!strcasecmp(action_text, "stop")) {
			/* Stop the recording */
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_boolean(audio)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a boolean)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a boolean)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_boolean(video)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a boolean)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a boolean)");
				goto error;
			}
			if(!audio && !video) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Missing audio and/or video\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Missing audio and/or video");
				goto error;
			}
			if(audio && json_is_true(audio) && mp->source->arc) {
				/* Close the audio recording */
				janus_recorder_close(mp->source->arc);
				JANUS_LOG(LOG_INFO, "[%s] Closed audio recording %s\n", mp->name, mp->source->arc->filename ? mp->source->arc->filename : "??");
				janus_recorder *tmp = mp->source->arc;
				mp->source->arc = NULL;
				janus_recorder_free(tmp);
			}
			if(video && json_is_true(video) && mp->source->vrc) {
				/* Close the video recording */
				janus_recorder_close(mp->source->vrc);
				JANUS_LOG(LOG_INFO, "[%s] Closed video recording %s\n", mp->name, mp->source->vrc->filename ? mp->source->vrc->filename : "??");
				janus_recorder *tmp = mp->source->vrc;
				mp->source->vrc = NULL;
				janus_recorder_free(tmp);
			}
			janus_mutex_unlock(&mountpoints_mutex);
			/* Send a success response back */
			response = json_object();
			json_object_set_new(response, "streaming", json_string("ok"));
			goto plugin_response;
		}
		#endif // record
	} else if(!strcasecmp(request_text, "watch") || !strcasecmp(request_text, "start")
			|| !strcasecmp(request_text, "pause") || !strcasecmp(request_text, "stop")
			|| !strcasecmp(request_text, "switch")) {
		/* These messages are handled asynchronously */
		cm_rtpbcast_message *msg = g_malloc0(sizeof(cm_rtpbcast_message));
		if(msg == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			error_code = CM_RTPBCAST_ERROR_UNKNOWN_ERROR;
			g_snprintf(error_cause, 512, "Memory error");
			goto error;
		}

		g_free(message);
		msg->handle = handle;
		msg->transaction = transaction;
		msg->message = root;
		msg->sdp_type = sdp_type;
		msg->sdp = sdp;

		g_async_queue_push(messages, msg);

		return janus_plugin_result_new(JANUS_PLUGIN_OK_WAIT, NULL);
	} else {
		JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
		error_code = CM_RTPBCAST_ERROR_INVALID_REQUEST;
		g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
		goto error;
	}

plugin_response:
		{
			if(!response) {
				error_code = CM_RTPBCAST_ERROR_UNKNOWN_ERROR;
				g_snprintf(error_cause, 512, "Invalid response");
				goto error;
			}
			if(root != NULL)
				json_decref(root);
			g_free(transaction);
			g_free(message);
			g_free(sdp_type);
			g_free(sdp);

			if (sources != NULL)
				g_array_free(sources, TRUE);

			char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(response);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
			g_free(response_text);
			return result;
		}

error:
		{
			if(root != NULL)
				json_decref(root);
			g_free(transaction);
			g_free(message);
			g_free(sdp_type);
			g_free(sdp);

			if (sources != NULL)
				g_array_free(sources, TRUE);

			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, event_text);
			g_free(event_text);
			return result;
		}

}

void cm_rtpbcast_setup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "WebRTC media is now available\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	g_atomic_int_set(&session->hangingup, 0);
	/* TODO Only start streaming when we get this event */
	memset(&session->context, 0, sizeof(session->context));
	session->started = TRUE;
	/* Prepare JSON event */
	json_t *event = json_object();
	json_object_set_new(event, "streaming", json_string("event"));
	json_t *result = json_object();
	json_object_set_new(result, "status", json_string("started"));
	json_object_set_new(event, "result", result);
	char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(event);
	JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
	int ret = gateway->push_event(handle, &cm_rtpbcast_plugin, NULL, event_text, NULL, NULL);
	JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
	g_free(event_text);
}

void cm_rtpbcast_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* FIXME We don't care about what the browser sends us, we're sendonly */
}

void cm_rtpbcast_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* Get the session */
	janus_mutex_lock(&sessions_mutex);
	cm_rtpbcast_session *sessid = g_hash_table_lookup(sessions, handle);
	janus_mutex_unlock(&sessions_mutex);

	/* If session not found, abort, TODO @landswellsong maybe complain in the log */
	if (sessid == NULL)
		return;

	/* We might interested in the available bandwidth that the user advertizes */
	uint64_t bw = janus_rtcp_get_remb(buf, len);
	if(bw > 0) {
		JANUS_LOG(LOG_HUGE, "REMB for this PeerConnection: %"SCNu64"\n", bw);
		sessid->remb = bw;

		FILE *fp=fopen("/tmp/stats.csv", "a");
		fprintf(fp,"%lld, %lld, %lld", GPOINTER_TO_UINT(handle), janus_get_monotonic_time(), bw);
		fclose(fp);

		/* If the session is watching something, let's see if it needs switching */
		if (sessid->source) {
			/* Switching if remb falls withing the bands of upgrade and downgrade averages */
			if (bw < sessid->source->stats.cur_down || bw > sessid->source->stats.cur_up) {
				cm_rtpbcast_rtp_source *src =
					cm_rtpbcast_pick_source(sessid->source->mp->sources, bw);

				/* Check if we really need to switch */
				if (src != sessid->source) {
					janus_mutex_lock(&sessid->source->mutex);
					sessid->source->listeners = g_list_remove_all(sessid->source->listeners, sessid);
					sessid->source = src;
					janus_mutex_unlock(&sessid->source->mutex);

					janus_mutex_lock(&src->mutex);
					src->listeners = g_list_append(src->listeners, sessid);
					janus_mutex_unlock(&src->mutex);
				}
			}
		}
	}
	/* FIXME Maybe we should care about RTCP, but not now */
}

void cm_rtpbcast_hangup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "No WebRTC media anymore\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	if(g_atomic_int_add(&session->hangingup, 1))
		return;
	/* FIXME Simulate a "stop" coming from the browser */
	cm_rtpbcast_message *msg = g_malloc0(sizeof(cm_rtpbcast_message));
	msg->handle = handle;
	msg->message = json_loads("{\"request\":\"stop\"}", 0, NULL);
	msg->transaction = NULL;
	msg->sdp_type = NULL;
	msg->sdp = NULL;
	g_async_queue_push(messages, msg);
}

/* Thread to handle incoming messages */
static void *cm_rtpbcast_handler(void *data) {
	JANUS_LOG(LOG_VERB, "Joining CM RTP Broadcast handler thread\n");
	cm_rtpbcast_message *msg = NULL;
	int error_code = 0;
	char *error_cause = g_malloc0(1024);
	if(error_cause == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	json_t *root = NULL;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		if(!messages || (msg = g_async_queue_try_pop(messages)) == NULL) {
			usleep(50000);
			continue;
		}
		cm_rtpbcast_session *session = (cm_rtpbcast_session *)msg->handle->plugin_handle;
		if(!session) {
			JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
			cm_rtpbcast_message_free(msg);
			continue;
		}
		if(session->destroyed) {
			cm_rtpbcast_message_free(msg);
			continue;
		}
		/* Handle request */
		error_code = 0;
		root = NULL;
		if(msg->message == NULL) {
			JANUS_LOG(LOG_ERR, "No message??\n");
			error_code = CM_RTPBCAST_ERROR_NO_MESSAGE;
			g_snprintf(error_cause, 512, "%s", "No message??");
			goto error;
		}
		root = msg->message;
		/* Get the request first */
		json_t *request = json_object_get(root, "request");
		if(!request) {
			JANUS_LOG(LOG_ERR, "Missing element (request)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (request)");
			goto error;
		}
		if(!json_is_string(request)) {
			JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
			goto error;
		}
		const char *request_text = json_string_value(request);
		json_t *result = NULL;
		const char *sdp_type = NULL;
		char *sdp = NULL;
		/* All these requests can only be handled asynchronously */
		if(!strcasecmp(request_text, "watch")) {
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_string(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
				goto error;
			}
			const char *id_value = json_string_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			cm_rtpbcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
				goto error;
			}
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to watch mountpoint/stream %s\n", id_value);
			session->stopping = FALSE;

			session->source = cm_rtpbcast_pick_source(mp->sources, session->remb);
			cm_rtpbcast_rtp_source *src = session->source;

			/* TODO Check if user is already watching a stream, if the video is active, etc. */
			/* TODO @landswellsong cover these original TODOs */
			/* TODO @landswellsong make sure "switch" and "auto-switch" send SDPs with correct codecs */
			janus_mutex_lock(&src->mutex);
			src->listeners = g_list_append(src->listeners, session);
			janus_mutex_unlock(&src->mutex);
			sdp_type = "offer";	/* We're always going to do the offer ourselves, never answer */
			char sdptemp[2048];
			memset(sdptemp, 0, 2048);
			gchar buffer[512];
			memset(buffer, 0, 512);
			gint64 sessid = janus_get_real_time();
			gint64 version = sessid;	/* FIXME This needs to be increased when it changes, so time should be ok */
			g_snprintf(buffer, 512,
				"v=0\r\no=%s %"SCNu64" %"SCNu64" IN IP4 127.0.0.1\r\n",
					"-", sessid, version);
			g_strlcat(sdptemp, buffer, 2048);
			g_strlcat(sdptemp, "s=CM RTP Broadcast Test\r\nt=0 0\r\n", 2048); /* FIXME @landswellsong: maybe some sane name here? */
			cm_rtpbcast_codecs codecs = src->codecs;

			size_t j;
			for (j = AUDIO; j <= VIDEO; j++) {
				if(codecs.pt[j] >= 0) {
					/* Add audio/video line */
					g_snprintf(buffer, 512,
						"m=%s 1 RTP/SAVPF %d\r\n"
						"c=IN IP4 1.1.1.1\r\n",
						av_names[j],
						codecs.pt[j]);
					g_strlcat(sdptemp, buffer, 2048);
					if(codecs.rtpmap[j]) {
						g_snprintf(buffer, 512,
							"a=rtpmap:%d %s\r\n",
							codecs.pt[j], codecs.rtpmap[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					if(codecs.fmtp[j]) {
						g_snprintf(buffer, 512,
							"a=fmtp:%d %s\r\n",
							codecs.pt[j], codecs.fmtp[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					if (j == VIDEO) {
						g_snprintf(buffer, 512,
							"a=rtcp-fb:%d nack\r\n",
							codecs.pt[j]);
						g_strlcat(sdptemp, buffer, 2048);
						g_snprintf(buffer, 512,
							"a=rtcp-fb:%d goog-remb\r\n",
							codecs.pt[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					g_strlcat(sdptemp, "a=sendonly\r\n", 2048);
				}
			}

			sdp = g_strdup(sdptemp);
			JANUS_LOG(LOG_VERB, "Going to offer this SDP:\n%s\n", sdp);
			result = json_object();
			json_object_set_new(result, "status", json_string("preparing"));
		} else if(!strcasecmp(request_text, "start")) {
			if(session->source == NULL) {
				JANUS_LOG(LOG_VERB, "Can't start: no mountpoint set\n");
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Starting the streaming\n");
			session->paused = FALSE;
			result = json_object();
			/* We wait for the setup_media event to start: on the other hand, it may have already arrived */
			json_object_set_new(result, "status", json_string(session->started ? "started" : "starting"));
		} else if(!strcasecmp(request_text, "pause")) {
			if(session->source == NULL) {
				JANUS_LOG(LOG_VERB, "Can't pause: no mountpoint set\n");
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Pausing the streaming\n");
			session->paused = TRUE;
			result = json_object();
			json_object_set_new(result, "status", json_string("pausing"));
		} else if(!strcasecmp(request_text, "switch")) {
			#if 0
			/* This listener wants to switch to a different mountpoint
			 * NOTE: this only works for live RTP streams as of now: you
			 * cannot, for instance, switch from a live RTP mountpoint to
			 * an on demand one or viceversa (TBD.) */
			cm_rtpbcast_mountpoint *oldmp = session->mountpoint;
			if(oldmp == NULL) {
				JANUS_LOG(LOG_VERB, "Can't switch: not on a mountpoint\n");
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't switch: not on a mountpoint");
				goto error;
			}
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_string(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
				goto error;
			}
			char *id_value = json_string_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			cm_rtpbcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
				goto error;
			}
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to switch to mountpoint/stream %s (old: %s)\n", id_value, oldmp->id);
			session->paused = TRUE;
			/* Unsubscribe from the previous mountpoint and subscribe to the new one */
			janus_mutex_lock(&oldmp->mutex);
			oldmp->listeners = g_list_remove_all(oldmp->listeners, session);
			janus_mutex_unlock(&oldmp->mutex);
			/* Subscribe to the new one */
			janus_mutex_lock(&mp->mutex);
			mp->listeners = g_list_append(mp->listeners, session);
			janus_mutex_unlock(&mp->mutex);
			session->mountpoint = mp;
			session->paused = FALSE;
			/* Done */
			result = json_object();
			json_object_set_new(result, "streaming", json_string("event"));
			json_object_set_new(result, "switched", json_string("ok"));
			json_object_set_new(result, "id", json_string(id_value));
			#endif // start
		} else if(!strcasecmp(request_text, "stop")) {
			if(session->stopping || !session->started) {
				/* Been there, done that: ignore */
				cm_rtpbcast_message_free(msg);
				continue;
			}
			JANUS_LOG(LOG_VERB, "Stopping the streaming\n");
			session->stopping = TRUE;
			session->started = FALSE;
			session->paused = FALSE;
			result = json_object();
			json_object_set_new(result, "status", json_string("stopping"));
			if(session->source) {
				janus_mutex_lock(&session->source->mutex);
				JANUS_LOG(LOG_VERB, "  -- Removing the session from the mountpoint listeners\n");
				if(g_list_find(session->source->listeners, session) != NULL) {
					JANUS_LOG(LOG_VERB, "  -- -- Found!\n");
				}
				session->source->listeners = g_list_remove_all(session->source->listeners, session);
				janus_mutex_unlock(&session->source->mutex);
			}
			session->source = NULL;
			/* Tell the core to tear down the PeerConnection, hangup_media will do the rest */
			gateway->close_pc(session->handle);
		} else {
			JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
			error_code = CM_RTPBCAST_ERROR_INVALID_REQUEST;
			g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
			goto error;
		}

		/* Any SDP to handle? */
		if(msg->sdp) {
			JANUS_LOG(LOG_VERB, "This is involving a negotiation (%s) as well (but we really don't care):\n%s\n", msg->sdp_type, msg->sdp);
		}

		/* Prepare JSON event */
		json_t *event = json_object();
		json_object_set_new(event, "streaming", json_string("event"));
		if(result != NULL)
			json_object_set_new(event, "result", result);
		char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(event);
		JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
		int ret = gateway->push_event(msg->handle, &cm_rtpbcast_plugin, msg->transaction, event_text, sdp_type, sdp);
		JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
		g_free(event_text);
		if(sdp)
			g_free(sdp);
		cm_rtpbcast_message_free(msg);
		continue;

error:
		{
			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
			int ret = gateway->push_event(msg->handle, &cm_rtpbcast_plugin, msg->transaction, event_text, NULL, NULL);
			JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			g_free(event_text);
			cm_rtpbcast_message_free(msg);
		}
	}
	g_free(error_cause);
	JANUS_LOG(LOG_VERB, "Leaving CM RTP Broadcast handler thread\n");
	return NULL;
}

/* Helpers to create a listener filedescriptor */
static int cm_rtpbcast_create_fd(int port, in_addr_t mcast, const char* listenername, const char* medianame, const char* mountpointname) {
	struct sockaddr_in address;
	int fd = socket(AF_INET, SOCK_DGRAM, 0);
	if(fd < 0) {
		JANUS_LOG(LOG_ERR, "[%s] Cannot create socket for %s...\n", mountpointname, medianame);
		return -1;
	}
	if(port > 0) {
		int yes = 1;	/* For setsockopt() SO_REUSEADDR */
		setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

		if(IN_MULTICAST(ntohl(mcast))) {
#ifdef IP_MULTICAST_ALL
			int mc_all = 0;
			if((setsockopt(fd, IPPROTO_IP, IP_MULTICAST_ALL, (void*) &mc_all, sizeof(mc_all))) < 0) {
				JANUS_LOG(LOG_ERR, "[%s] %s listener setsockopt IP_MULTICAST_ALL failed\n", mountpointname, listenername);
				close(fd);
				return -1;
			}
#endif
			struct ip_mreq mreq;
			memset(&mreq, 0, sizeof(mreq));
			mreq.imr_multiaddr.s_addr = mcast;
			if(setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(struct ip_mreq)) == -1) {
				JANUS_LOG(LOG_ERR, "[%s] %s listener IP_ADD_MEMBERSHIP failed\n", mountpointname, listenername);
				close(fd);
				return -1;
			}
			JANUS_LOG(LOG_ERR, "[%s] %s listener IP_ADD_MEMBERSHIP ok\n", mountpointname, listenername);
		}
	}

	address.sin_family = AF_INET;
	address.sin_port = htons(port);
	address.sin_addr.s_addr = INADDR_ANY;
	if(bind(fd, (struct sockaddr *)(&address), sizeof(struct sockaddr)) < 0) {
		JANUS_LOG(LOG_ERR, "[%s] Bind failed for %s (port %d)...\n", mountpointname, medianame, port);
		close(fd);
		return -1;
	}
	return fd;
}

/* Helpers to destroy a streaming mountpoint. */
static void cm_rtpbcast_rtp_source_free(gpointer src) {
	cm_rtpbcast_rtp_source *source = *((cm_rtpbcast_rtp_source **)src);

	size_t j;
	for (j = AUDIO; j <= VIDEO; j++) {
		if(source->fd[j] > 0) {
			close(source->fd[j]);
		}
		g_free(source->codecs.rtpmap[j]);
		g_free(source->codecs.fmtp[j]);

		/* Remove ports from used ports */
		cm_rtpbcast_port_manager_free(source->port[j]);
	}

	janus_mutex_lock(&source->mutex);
	g_list_free(source->listeners);
	janus_mutex_unlock(&source->mutex);

	g_free(source);
}

static void cm_rtpbcast_mountpoint_free(cm_rtpbcast_mountpoint *mp) {
	mp->destroyed = janus_get_monotonic_time();

	g_free(mp->id);
	g_free(mp->name);
	g_free(mp->description);

	if (mp->sources) /* TODO: @landswellsong: see if this correctly deallocates everything */
		g_array_free(mp->sources, TRUE);

	g_free(mp);
}

/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
cm_rtpbcast_mountpoint *cm_rtpbcast_create_rtp_source(
		char *id, char *name, char *desc, gboolean recorded,
		const char* allowed_ip, GArray *requests) {
	if(name == NULL) {
		JANUS_LOG(LOG_VERB, "Missing name, will generate a random one...\n");
	}
	cm_rtpbcast_mountpoint *live_rtp = g_malloc0(sizeof(cm_rtpbcast_mountpoint));
	if(live_rtp == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	live_rtp->id = g_strdup(id);
	char tempname[255];
	if(!name) {
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%s", live_rtp->id);
	}
	live_rtp->name = g_strdup(name ? name : tempname);
	live_rtp->description = g_strdup(desc != NULL ? desc : (name ? name : tempname));
	live_rtp->enabled = TRUE;
	live_rtp->recorded = recorded;
	live_rtp->last_thumbnail = janus_get_monotonic_time();

	live_rtp->rc[AUDIO] = NULL;
	live_rtp->rc[VIDEO] = NULL;
	live_rtp->trc[0] = NULL;

	/* Setting allowed IP's */
	live_rtp->whitelisted = FALSE;
	if (allowed_ip) {
		struct hostent *he = gethostbyname2(allowed_ip, AF_INET);
		if (he) {
			memcpy(&live_rtp->allowed_ip.s_addr, he->h_addr, sizeof(he->h_length));
			live_rtp->whitelisted = TRUE;
		}
	}


	/* Iterating over requests array to add all streams */
	live_rtp->sources = g_array_sized_new(FALSE, FALSE, sizeof(cm_rtpbcast_rtp_source*), requests->len);
	g_array_set_clear_func(live_rtp->sources, (GDestroyNotify) cm_rtpbcast_rtp_source_free);
	guint i,j;
	for (i = 0; i < requests->len; i++) {
		cm_rtpbcast_rtp_source_request req = g_array_index(requests, cm_rtpbcast_rtp_source_request, i);
		cm_rtpbcast_rtp_source *live_rtp_source = g_malloc0(sizeof(cm_rtpbcast_rtp_source));

		if(live_rtp_source == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			goto error;
		}

		live_rtp_source->mp = live_rtp;
		janus_mutex_init(&live_rtp_source->stats.stat_mutex);
		memset(&live_rtp_source->stats, 0, sizeof(live_rtp_source->stats));

		live_rtp_source->listeners = NULL;
		janus_mutex_init(&live_rtp_source->mutex);

		for (j = AUDIO; j <= VIDEO; j++) {
			live_rtp_source->mcast[j] = req.mcast[j] ? inet_addr(req.mcast[j]) : INADDR_ANY;
			live_rtp_source->fd[j] = -1;
			live_rtp_source->codecs.pt[j] = req.codec[j];
			live_rtp_source->codecs.rtpmap[j] = req.rtpmap[j] ? g_strdup(req.rtpmap[j]) : NULL;
			live_rtp_source->codecs.fmtp[j] = req.fmtp[j] ? g_strdup(req.fmtp[j]) : NULL;

			/* Checking the next valid port */
			/* TODO @landswellsong: hash table only remembers the source, do we need it
							to remember whether it was video or audio too? */
			live_rtp_source->port[j] = cm_rtpbcast_port_manager_assign(live_rtp_source);
		}
		g_array_append_val(live_rtp->sources, live_rtp_source);
	}

	live_rtp->destroyed = 0;

	/* If we need recording, start it before creating threads */
	if (recorded)
		cm_rtpbcast_start_recording(live_rtp);

	for (i = 0; i < live_rtp->sources->len; i++) {
		char tempname[256];
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%s %d", live_rtp->id, i);

		GError *error = NULL;
		cm_rtpbcast_rtp_relay_thread_data *dt = g_malloc0(sizeof(cm_rtpbcast_rtp_relay_thread_data)); /* Memory fred within */
		dt->mp = live_rtp;
		dt->i = i;
		g_thread_try_new(tempname, &cm_rtpbcast_relay_thread, dt, &error);
		if(error != NULL) {
			JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP thread...\n", error->code, error->message ? error->message : "??");
			goto error;
		}
	}
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_insert(mountpoints, g_strdup(live_rtp->id), live_rtp);
	janus_mutex_unlock(&mountpoints_mutex);
	return live_rtp;

	error:
	g_free(live_rtp->id);
	g_free(live_rtp->name);
	g_free(live_rtp->description);
	g_array_free(live_rtp->sources, TRUE);
	return NULL;
}

/* FIXME Test thread to relay RTP frames coming from gstreamer/ffmpeg/others */
static void *cm_rtpbcast_relay_thread(void *data) {
	JANUS_LOG(LOG_VERB, "Starting streaming relay thread\n");
	cm_rtpbcast_rtp_relay_thread_data *tdata = (cm_rtpbcast_rtp_relay_thread_data *)data;
	cm_rtpbcast_mountpoint *mountpoint = tdata->mp;
	guint nstream = tdata->i;
	cm_rtpbcast_rtp_source *source = g_array_index(mountpoint->sources, cm_rtpbcast_rtp_source*, nstream);
  /* Data no longer needed */
	g_free(data);

	if(!mountpoint) {
		JANUS_LOG(LOG_ERR, "Invalid mountpoint!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	if(source == NULL) {
		JANUS_LOG(LOG_ERR, "[%s] Invalid RTP source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}

	size_t j;
	for (j = AUDIO; j <= VIDEO; j++) {
		static const char *lnames[] = { "Audio", "Video" };
		/* Socket stuff */
		if((source->fd[j] < 0) && (source->port[j] >= 0)) {
			source->fd[j] = cm_rtpbcast_create_fd(source->port[j], source->mcast[j], lnames[j], av_names[j], mountpoint->name);
			if(source->fd[j] < 0) {
				g_thread_unref(g_thread_self());
				return NULL;
			}
			JANUS_LOG(LOG_VERB, "[%s] %s listener bound to port %d\n", lnames[j], mountpoint->name, source->port[j]);
		}
	}

	char *name = g_strdup(mountpoint->name ? mountpoint->name : "??");
	/* Needed to fix seq and ts */
	cm_rtpbcast_context ctx;
	memset(&ctx, 0, sizeof(ctx));

	/* Loop */
	socklen_t addrlen;
	struct sockaddr_in remote;
	int resfd = 0, bytes = 0;
	struct pollfd fds[2];
	char buffer[1500];
	memset(buffer, 0, 1500);
	cm_rtpbcast_rtp_relay_packet packet;

	while(!g_atomic_int_get(&stopping) && !mountpoint->destroyed) {
		/* Wait for some data */
		for (j = AUDIO; j <= VIDEO; j++) {
			fds[j].fd = 0;
			fds[j].events = 0;
			fds[j].revents = 0;
			if(source->fd[j] > 0) {
				fds[j].fd = source->fd[j];
				fds[j].events = POLLIN;
			}
		}

		resfd = poll(fds, 2, 1000);
		if(resfd < 0) {
			JANUS_LOG(LOG_ERR, "[%s] Error polling... %d (%s)\n", mountpoint->name, errno, strerror(errno));
			break;
		} else if(resfd == 0) {
			cm_rtpbcast_stats_update(&source->stats, 0);
			/* No data, keep going */
			continue;
		}

		for (j = AUDIO; j <= VIDEO; j++) {
			if(source->fd[j] && (fds[j].revents & POLLIN)) {
				/* Got something (RTP) */
				fds[j].revents = 0;
				if(source->active == FALSE) {
					source->active = TRUE;
					/* After inactivity we reset stats */
					cm_rtpbcast_stats_restart(&source->stats);
				}
				addrlen = sizeof(remote);
				bytes = recvfrom(source->fd[j], buffer, 1500, 0, (struct sockaddr*)&remote, &addrlen);
				/* Note we only update stats for legitimate packets */
				if(source->mp && source->mp->whitelisted &&
					memcmp(&remote.sin_addr.s_addr, &source->mp->allowed_ip.s_addr, sizeof(in_addr_t)) != 0) {
					char buf1[512], buf2[512]; /* inet_ntoa operates on static buffers so we can't call two in same LOG() */
					strncpy(buf1, inet_ntoa(remote.sin_addr), 512);
					strncpy(buf2, inet_ntoa(source->mp->allowed_ip), 512);
					JANUS_LOG(LOG_WARN, "[%s] Got packet from %s whereas only %s is whitelisted\n",
						source->mp->id, buf1, buf2);
					continue;
				}

				/* Note we only update stats for legitimate packets */
				/* FIXME @landswellsong are we only expecting IPv4 ? */
				cm_rtpbcast_stats_update(&source->stats, bytes + sizeof(struct ip) + sizeof(struct udphdr));
				//~ JANUS_LOG(LOG_VERB, "************************\nGot %d bytes on the %і channel...\n", av_names[j], bytes);
				/* If paused, ignore this packet */
				if(!mountpoint->enabled)
					continue;
				rtp_header *rtp = (rtp_header *)buffer;
				//~ JANUS_LOG(LOG_VERB, " ... parsed RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
					//~ ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
				/* Relay on all sessions */
				packet.data = rtp;
				packet.length = bytes;
				packet.is_video = (j == VIDEO);
				/* Do we have a new stream? */
				if(ntohl(packet.data->ssrc) != ctx.last_ssrc[j]) {
					ctx.last_ssrc[j] = ntohl(packet.data->ssrc);
					JANUS_LOG(LOG_INFO, "[%s] New %s stream! (ssrc=%u)\n", name, av_names[j], ctx.last_ssrc[j]);
					ctx.base_ts_prev[j] = ctx.last_ts[j];
					ctx.base_ts[j] = ntohl(packet.data->timestamp);
					ctx.base_seq_prev[j] = ctx.last_seq[j];
					ctx.base_seq[j] = ntohs(packet.data->seq_number);
				}
				/* FIXME We're assuming Opus here for audio and 15fps for video... */
				ctx.last_ts[j] = (ntohl(packet.data->timestamp)-ctx.base_ts[j])+ctx.base_ts_prev[j]+ (j == AUDIO? 960 : 4500);
				packet.data->timestamp = htonl(ctx.last_ts[j]);
				ctx.last_seq[j] = (ntohs(packet.data->seq_number)-ctx.base_seq[j])+ctx.base_seq_prev[j]+1;
				packet.data->seq_number = htons(ctx.last_seq[j]);
				//~ JANUS_LOG(LOG_VERB, " ... updated RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
					//~ ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
				packet.data->type = source->codecs.pt[j];
				/* Is there a recorder? */
				/* FIXME @landswellsong support arbitrary stream recording */
				/* FIXME @landswellsong probably put mutexes around recorders */
				if(nstream == 0 && mountpoint->rc[j]) {
					// @landswellsong: diabling logging here, streams are recorded by default and this will produce a mess
					// JANUS_LOG(LOG_HUGE, "[%s] Saving %s frame (%d bytes)\n", name, av_names[j], bytes);
					janus_recorder_save_frame(mountpoint->rc[j], buffer, bytes);
				}

				if (nstream == 0 && j == VIDEO) {
					/* Is it time to do thumbnailing? */
					guint64 ml = janus_get_monotonic_time();
					if (!mountpoint->trc[0] && (ml > mountpoint->last_thumbnail
						+ cm_rtpbcast_settings.thumbnailing_interval * 1000000)) {
							cm_rtpbcast_start_thumbnailing(mountpoint);
							mountpoint->last_thumbnail = ml;
					}

					/* After the call it might update */
					if (mountpoint->trc[0])
						janus_recorder_save_frame(mountpoint->trc[0], buffer, bytes);

					/* Is it time to stop the thumbnailing? */
					if (mountpoint->trc[0] && (ml > mountpoint->last_thumbnail
						+ cm_rtpbcast_settings.thumbnailing_duration * 1000000)) {
						cm_rtpbcast_stop_thumbnailing(mountpoint);
					}
				}

				/* Backup the actual timestamp and sequence number set by the restreamer, in case switching is involved */
				packet.timestamp = ntohl(packet.data->timestamp);
				packet.seq_number = ntohs(packet.data->seq_number);
				/* Go! */
				janus_mutex_lock(&source->mutex);
				g_list_foreach(source->listeners, cm_rtpbcast_relay_rtp_packet, &packet);
				janus_mutex_unlock(&source->mutex);
				continue;
			}
		}
	}
	JANUS_LOG(LOG_VERB, "[%s] Leaving streaming relay thread\n", name);
	g_free(name);
	g_thread_unref(g_thread_self());
	return NULL;
}

static void cm_rtpbcast_relay_rtp_packet(gpointer data, gpointer user_data) {
	cm_rtpbcast_rtp_relay_packet *packet = (cm_rtpbcast_rtp_relay_packet *)user_data;
	if(!packet || !packet->data || packet->length < 1) {
		JANUS_LOG(LOG_ERR, "Invalid packet...\n");
		return;
	}
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)data;
	if(!session || !session->handle) {
		//~ JANUS_LOG(LOG_ERR, "Invalid session...\n");
		return;
	}
	if(!session->started || session->paused) {
		//~ JANUS_LOG(LOG_ERR, "Streaming not started yet for this session...\n");
		return;
	}

	/* Make sure there hasn't been a publisher switch by checking the SSRC */
	size_t j = packet->is_video? VIDEO : AUDIO;
	if(ntohl(packet->data->ssrc) != session->context.last_ssrc[j]) {
		session->context.last_ssrc[j] = ntohl(packet->data->ssrc);
		session->context.base_ts_prev[j] = session->context.last_ts[j];
		session->context.base_ts[j] = packet->timestamp;
		session->context.base_seq_prev[j] = session->context.last_seq[j];
		session->context.base_seq[j] = packet->seq_number;
	}
	/* Compute a coherent timestamp and sequence number */
	/* FIXME When switching, we assume 15fps for video and Opus and so a 960 ts step for audio */
	session->context.last_ts[j] = (packet->timestamp-session->context.base_ts[j])
		+ session->context.base_ts_prev[j]+(packet->is_video? 4500 : 960);
	session->context.last_seq[j] = (packet->seq_number-session->context.base_seq[j])+session->context.base_seq_prev[j]+1;
	/* Update the timestamp and sequence number in the RTP packet, and send it */
	packet->data->timestamp = htonl(session->context.last_ts[j]);
	packet->data->seq_number = htons(session->context.last_seq[j]);
	if(gateway != NULL)
		gateway->relay_rtp(session->handle, packet->is_video, (char *)packet->data, packet->length);
	/* Restore the timestamp and sequence number to what the publisher set them to */
	packet->data->timestamp = htonl(packet->timestamp);
	packet->data->seq_number = htons(packet->seq_number);
	return;
}

void cm_rtpbcast_port_manager_init(guint minport, guint maxport) {
	port_manager.used_ports = g_hash_table_new(NULL, NULL);
	janus_mutex_init(&port_manager.used_ports_mutex);

	/* Generating random sequence of ports */
	GList *straight = NULL;
	guint i;
	for (i = minport; i <= maxport; i++)
		straight = g_list_prepend(straight, GUINT_TO_POINTER(i));
	guint len = port_manager.ports_available = maxport - minport + 1;

	while (len > 0) {
		GList *el = g_list_nth(straight, g_random_int() % (len--));
		port_manager.free_ports = g_list_prepend(port_manager.free_ports, GUINT_TO_POINTER(el->data));
		straight = g_list_delete_link(straight, el);
	}

	/* Shouldn't happen but just in case */
	if (straight)
		g_list_free(straight);
}

guint cm_rtpbcast_port_manager_assign(gpointer src) {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	/* Inserting the new port to hash table and removing from the list */
	guint res = GPOINTER_TO_UINT(port_manager.free_ports->data);
	port_manager.free_ports = g_list_delete_link(port_manager.free_ports, port_manager.free_ports);
	g_hash_table_insert(port_manager.used_ports, GUINT_TO_POINTER(res), src);

	port_manager.ports_available--;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
	return res;
}

void cm_rtpbcast_port_manager_free(guint port) {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	/* Removing the port from the hash table and inserting to the list */
	g_hash_table_remove(port_manager.used_ports, GUINT_TO_POINTER(port));
	port_manager.free_ports = g_list_insert_before(port_manager.free_ports,
	 	g_list_nth(port_manager.free_ports, port_manager.ports_available), GUINT_TO_POINTER(port));

	port_manager.ports_available++;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
}

void cm_rtpbcast_port_manager_destroy() {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	g_hash_table_destroy(port_manager.used_ports);
	g_list_free(port_manager.free_ports);
	port_manager.ports_available = 0;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
}

static void cm_rtpbcast_stats_restart(cm_rtpbcast_stats *st) {
	janus_mutex_lock(&st->stat_mutex);

	memset(st, 0, sizeof(*st));
	guint64 ml = janus_get_monotonic_time();
	st->start_usec = ml;
	st->last_avg_usec = ml;
	st->last_avg_up_usec = ml;
	st->last_avg_down_usec = ml;

	janus_mutex_unlock(&st->stat_mutex);
}

static void cm_rtpbcast_stats_update(cm_rtpbcast_stats *st, int bytes) {
	janus_mutex_lock(&st->stat_mutex);

	/* This overflows at 17179869184 GB of traffic just in case :) */
	st->bytes_since_start += bytes;
	st->bytes_since_last_avg += bytes;
	st->bytes_since_last_avg_up += bytes;
	st->bytes_since_last_avg_down += bytes;

	guint64 ml = janus_get_monotonic_time();
	guint64 delay;

	guint64 *bytes_since[] = {
			&st->bytes_since_last_avg,
			&st->bytes_since_last_avg_up,
			&st->bytes_since_last_avg_down
		};
	gdouble *avg_vars[] = {
			&st->cur,
			&st->cur_up,
			&st->cur_down
		};
	guint64 delays[] = {
			STAT_UPDATE_DELAY,
			cm_rtpbcast_settings.upgrade_avg_time * STAT_UPDATE_DELAY,
			cm_rtpbcast_settings.downgrade_avg_time * STAT_UPDATE_DELAY
		};
	guint64 *usec_vars[] = {
			&st->last_avg_usec,
			&st->last_avg_up_usec,
			&st->last_avg_down_usec
		};

	/* If we step over delay, calculate current and compare min/max */
	_foreach(i, avg_vars) {
		if (ml - *usec_vars[i] >= delays[i]) {
			/* Calculate */
			delay = ml - *usec_vars[i];
			*avg_vars[i] = (8.0L*10e5L)*(gdouble)(*bytes_since[i]) / (delay != 0 ? delay : 1);
			/* Reset timer */
			*bytes_since[i] = 0;
			*usec_vars[i] = ml;

			/* Only recording extrema for every second average */
			if (i == 0) {
				if (*avg_vars[i] > st->max)
					st->max = *avg_vars[i];
				if (*avg_vars[i] < st->min || st->min == 0.0L)
					st->min = *avg_vars[i];
			}
		}
	}

	/* Re-calculate average regardless */
	delay = ml - st->start_usec;
	st->avg = (8.0L*10e5L)*(gdouble)st->bytes_since_start / (delay != 0 ? delay : 1);

	janus_mutex_unlock(&st->stat_mutex);
}

cm_rtpbcast_rtp_source* cm_rtpbcast_pick_source(GArray *sources, guint64 remb) {
	/* If no sources, oh well */
	if (sources->len <= 0)
		return NULL;

	/* If we don't know the remb yet, return highest quality stream */
	if (remb == 0)
		return g_array_index(sources, cm_rtpbcast_rtp_source *, 0);

	/* Pick the source with bitrate less than REMB given or the worst quality if
	   no such source found */
	guint i = 0; cm_rtpbcast_rtp_source *src; guint64 source_remb;
	do {
		src = g_array_index(sources, cm_rtpbcast_rtp_source *, i++);
		janus_mutex_lock(&src->stats.stat_mutex);
		source_remb = (guint64)src->stats.avg;
		janus_mutex_unlock(&src->stats.stat_mutex);
	} while (i < sources->len && remb < source_remb);

	return src;
}

void cm_rtpbcast_store_event(json_t* response, const char *event_name) {
	if (!response)
		return;

	/* Creating outer layer JSON */
	json_t *envelope = json_object();

	json_object_set_new(envelope, "plugin", json_string(CM_RTPBCAST_PACKAGE));
	json_object_set_new(envelope, "event", json_string(event_name));
	json_object_set(envelope, "data", response);

	/* Generating an MD5 for filename */
	guint64 ml = janus_get_monotonic_time();
	char ml_str [512];
	g_snprintf(ml_str, 512, "%llu", (long long unsigned)ml);

	guint32 r = g_random_int();
	char r_str [512];
	g_snprintf(r_str, 512, "%u", r);

	char buf[512];
	g_snprintf(buf, 512, "%lu%llu%s", (long unsigned)r, (long long unsigned)ml, CM_RTPBCAST_PACKAGE);
	gchar *md5 = g_compute_checksum_for_string(G_CHECKSUM_MD5, buf, -1);

	/* Constructing the filename */
	char *fname = g_strdup(cm_rtpbcast_settings.job_pattern);

	const char *tags[] = {
		"#{time}",
		"#{rand}",
		"#{md5}",
		"#{plugin}"
	};

	const char *values[] = {
		ml_str,
		r_str,
		md5,
		CM_RTPBCAST_PACKAGE
	};

	_foreach (j, tags)
		fname = str_replace(fname, tags[j], values[j]);

	g_free(md5);

	char fullpath[512];
	g_snprintf(fullpath, 512, "%s/%s.json", cm_rtpbcast_settings.job_path, fname);
	g_free(fname);

	if (json_dump_file(envelope, fullpath, JSON_INDENT(4)))
		JANUS_LOG(LOG_ERR, "Error saving JSON to %s\n", fullpath);

	json_decref(envelope);
}

/* Generic functions for both recording and thumbnailing */
static void cm_rtpbcast_generic_start_recording(
		janus_recorder *recorders[],		/* Array or pointer to recorders */
		size_t start, size_t end, 			/* Inclusive, which ones to process */
		const char *fname_pattern,			/* Printf pattern for filename */
		const char *id,									/* streamChannelKey */
		const char *types[],						/* Type labels, per recorder */
		gboolean is_video[]							/* Whether stream is video, per recorder */
	) {
		/* FIXME @landswellsong which mutex we must lock? */
		/* TODO @landswellsong error reporting upward maybe? */
		size_t j; gboolean res = FALSE;
		for (j = start; j <= end; j++)
			res |= (recorders[j] != NULL);
		if (res)
			return;

		/* Event for notification */
		json_t *response = json_object();
		json_object_set_new(response, "id", json_string(id));

		/* Assuming streams contain both video and audio */
		guint64 mt = janus_get_monotonic_time();
		for (j = start; j <= end; j++) {
			char *fname = g_strdup(fname_pattern);

			guint64 ml = janus_get_monotonic_time();
			char ml_str [512];
			g_snprintf(ml_str, 512, "%llu", (long long unsigned)ml);

			const char *tags[] = {
				"#{time}",
				"#{id}",
				"#{type}"
			};

			const char *values[] = {
				ml_str,
				id,
				types[j]
			};

			_foreach (k, tags)
				fname = str_replace(fname, tags[k], values[k]);

			recorders[j] = janus_recorder_create(cm_rtpbcast_settings.archive_path, is_video[j], fname);
			g_free(fname);

			if(recorders[j] == NULL) {
				JANUS_LOG(LOG_ERR, "Error starting recorder for %s\n", types[j]);
			} else {
				char fname[512];
				g_snprintf(fname, 512, "%s/%s", recorders[j]->dir? recorders[j]->dir : "",
					recorders[j]->filename? recorders[j]->filename : "??");
				JANUS_LOG(LOG_INFO, "[%s] Recording %s started\n", id, types[j]);
				json_object_set_new(response, types[j], json_string(fname));
			}
		}

		/* Note that we are recording and notify  */
		res = FALSE;
		for (j = start; j <= end; j++)
			res |= (recorders[j] != NULL);

		json_decref(response);
}

static void cm_rtpbcast_generic_stop_recording(
	janus_recorder *recorders[],		/* Array or pointer to recorders */
	size_t start, size_t end, 			/* Inclusive, which ones to process */
	const char *id,									/* streamChannelKey */
	const char *types[],						/* Type labels, per recorder */
	const char *event_name				  /* JSON event name for notification */
	) {
	size_t j; gboolean res = TRUE;
	for (j = start; j <= end; j++)
		res &= (!recorders[j]);
	if (res)
		return;

	/* Event for notification */
	json_t *response = json_object();
	json_object_set_new(response, "id", json_string(id));

	for (j = start; j <= end; j++) {
		if (recorders[j]) {
			char fname[512];
			g_snprintf(fname, 512, "%s/%s", recorders[j]->dir? recorders[j]->dir : "",
				recorders[j]->filename? recorders[j]->filename : "??");
			janus_recorder_close(recorders[j]);
			json_object_set_new(response, types[j], json_string(fname));
			JANUS_LOG(LOG_INFO, "[%s] Closed %s recording %s\n", id, types[j], fname);
			janus_recorder *tmp = recorders[j];
			recorders[j] = NULL;
			janus_recorder_free(tmp);
		}
	}

	res = TRUE;
	for (j = start; j <= end; j++)
		res &= (!recorders[j]);
	if (res)
		cm_rtpbcast_store_event(response, event_name);

	json_decref(response);
}

void cm_rtpbcast_start_recording(cm_rtpbcast_mountpoint *mnt) {
	gboolean is_video[] = { FALSE, TRUE };
	cm_rtpbcast_generic_start_recording(
		mnt->rc,
		AUDIO, VIDEO,
		cm_rtpbcast_settings.recording_pattern,
		mnt->id,
		av_names,
		is_video
	);
}

void cm_rtpbcast_stop_recording(cm_rtpbcast_mountpoint *mnt) {
	cm_rtpbcast_generic_stop_recording(
		mnt->rc,
		AUDIO, VIDEO,
		mnt->id,
		av_names,
		"archive-finished"
	);
}

void cm_rtpbcast_start_thumbnailing(cm_rtpbcast_mountpoint *mnt) {
	gboolean is_video[] = { TRUE };
	const char *types[] = { "thumb"};
	cm_rtpbcast_generic_start_recording(
		mnt->trc,
		0, 0,
		cm_rtpbcast_settings.thumbnailing_pattern,
		mnt->id,
		types,
		is_video
	);
}

void cm_rtpbcast_stop_thumbnailing(cm_rtpbcast_mountpoint *mnt) {
	const char *types[] = { "thumb"};
	cm_rtpbcast_generic_stop_recording(
		mnt->trc,
		0, 0,
		mnt->id,
		types,
		"thumbnailing-finished"
	);
}

char *str_replace(char *instr, const char *needle, const char *replace) {
	GRegex* regex = g_regex_new(needle, 0, 0, NULL);
	char* new = g_regex_replace_literal(regex, instr, -1, 0, replace, 0, NULL);
	g_regex_unref (regex);
	g_free(instr);
	return new;
}

void cm_rtpbcast_mountpoint_destroy(gpointer data, gpointer user_data) {
	cm_rtpbcast_mountpoint * mp = (cm_rtpbcast_mountpoint *) data;
	if(!mp->destroyed) {
		/* FIXME Should we kick the current viewers as well? */
		guint i;
		for (i = 0; i < mp->sources->len; i++) {
			cm_rtpbcast_rtp_source *src = g_array_index(mp->sources,
				cm_rtpbcast_rtp_source *, i);

			janus_mutex_lock(&src->mutex);
			GList *viewer = g_list_first(src->listeners);
			/* Prepare JSON event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_t *result = json_object();
			json_object_set_new(result, "status", json_string("stopped"));
			json_object_set_new(event, "result", result);
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			while(viewer) {
				cm_rtpbcast_session *session = (cm_rtpbcast_session *)viewer->data;
				if(session != NULL) {
					session->stopping = TRUE;
					session->started = FALSE;
					session->paused = FALSE;
					session->source = NULL;
					/* Tell the core to tear down the PeerConnection, hangup_media will do the rest */
					gateway->push_event(session->handle, &cm_rtpbcast_plugin, NULL, event_text, NULL, NULL);
					gateway->close_pc(session->handle);
				}
				src->listeners = g_list_remove_all(src->listeners, session);
				viewer = g_list_first(src->listeners);
			}
			g_free(event_text);
			janus_mutex_unlock(&src->mutex);
		}

		/* If it's recording, stop it */
		if(mp->rc[AUDIO] || mp->rc[VIDEO])
			cm_rtpbcast_stop_recording(mp);

		if(mp->trc[0])
			cm_rtpbcast_stop_thumbnailing(mp);

		/* Remove from respective session */
		if(mp->session) {
			mp->session->mps = g_list_remove_all(mp->session->mps, mp);
			mp->session = NULL;
		}

		/* Remove mountpoint from the hashtable: this will get it destroyed */
		mp->destroyed = janus_get_monotonic_time();
		g_hash_table_remove(mountpoints, mp->id);
		/* Cleaning up and removing the mountpoint is done in a lazy way */
		old_mountpoints = g_list_append(old_mountpoints, mp);
	}
}
